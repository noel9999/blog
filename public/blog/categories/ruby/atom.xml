<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Noel Saga]]></title>
  <link href="http://noelsaga.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://noelsaga.herokuapp.com/"/>
  <updated>2015-07-23T02:07:25+08:00</updated>
  <id>http://noelsaga.herokuapp.com/</id>
  <author>
    <name><![CDATA[Noel]]></name>
    <email><![CDATA[terrorer9999@hotmail]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 類別變數]]></title>
    <link href="http://noelsaga.herokuapp.com/blog/2015/07/22/ruby-lei-bie-bian-shu/"/>
    <updated>2015-07-22T23:36:42+08:00</updated>
    <id>http://noelsaga.herokuapp.com/blog/2015/07/22/ruby-lei-bie-bian-shu</id>
    <content type="html"><![CDATA[<p>類別變數，有時也稱靜態變數，簡單說就是專屬於類別的變數，不依實體不同而有所差異，類別成員下皆共享的，因為是存在特定的記憶體區塊，所以不會因實體的存活期間所影響。</p>

<p>各個oop語言的類別變數大致的理念都是相同的，用法上可能會略有不同，今次是就來探討<code>ruby</code>的使用狀況。</p>

<!--more-->


<h2>類別變數種類</h2>

<p><code>ruby</code>的類別變數有區分以下兩種，而兩者都可以被類別方法正常存取與使用，但還是有差異如下：</p>

<blockquote><p>@@var => Class Variable  類別變數
@var => Class Instance Variable  類別實體變數</p></blockquote>

<h3>主要差異為：</h3>

<h3>1.<code>@@</code>可以給子類別繼承; <code>@</code>不可以</h3>

<p>{% codeblock lang:rb 類別變數繼承 %}
class Parent
  @@blood = :b
  @hobby = :car</p>

<p>  def self.blood</p>

<pre><code>@@blood
</code></pre>

<p>  end</p>

<p>  def self.hobby</p>

<pre><code>@hobby
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Parent
end</p>

<p>Parent.hobby # car
Child.hobby # nil
Parent.blood # b
Child.blodd # b</p>

<p>Child.instance_eval do
  @hobby = :coding
end
Child.hobby # coding
{% endcodeblock %}</p>

<hr />

<h3>2.<code>@@</code>雖可以被繼承，但由於所有類別都共用，故<code>@@</code>更改後也會影響其他類別所擁有的相同<code>@@</code>;<code>@</code>因為不會被繼承所以沒這問題</h3>

<p>所以使用<code>@@</code>的時候請小心，一般來說較常使用<code>@</code>來當做類別變數</p>

<p>{% codeblock lang:rb 類別變數共享問題 %}
class Parent
  @@blood = :b</p>

<p>  def self.blood</p>

<pre><code>@@blood
</code></pre>

<p>  end</p>

<p>  def self.blood=(value)</p>

<pre><code>@@blood = value
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Parent
end</p>

<p>Parent.blood # b
Child.blood # b
Child.blood = :c
Parent.blood # c
Child.blood # c
{% endcodeblock %}</p>

<hr />

<h3>3.<code>@@</code>可以給實體方法使用; <code>@</code>不可以</h3>

<p>因為<code>@</code>對實體方法的角度來看，會當做實體變數去讀取而非類別實體變數
{% codeblock lang:rb 實體方法使用類別變數 %}
class Parent
  @@blood = :b
  @hobby = :car</p>

<p>  def blood</p>

<pre><code>@@blood
</code></pre>

<p>  end</p>

<p>  def hobby</p>

<pre><code>@hobby
</code></pre>

<p>  end
end</p>

<p>dad = Parent.new
dad.blood # b
dad.hobby # nil
{% endcodeblock %}
如果實體方法想使用類別實體變數，那就改讓實體方法去呼叫類別方法即可</p>

<p>{% codeblock lang:rb %}
Parent.class_eval do
  def self.hobby</p>

<pre><code>@hobby
</code></pre>

<p>  end</p>

<p>  def get_hobby_by_class_method</p>

<pre><code>Parent.hobby
</code></pre>

<p>  end
end</p>

<p>mom = Parent.new
mom.hobby # nil
mom.get_hobby_by_class_method # car
{% endcodeblock %}</p>

<h2>補充</h2>

<p>換種類別方法定義的方式來看更複雜一點的例子
{% codeblock lang:rb %}
class Animal
  class &lt;&lt; self</p>

<pre><code>@@move = true
@@breath = "Air"
@food = %w(meat grass)
def description
  if @@move
    puts "We Can beathe #{@@breath}"
  end
end

def food
  @food ||= []
end

def food_list
  @food.each do |food|
    puts "We like #{food}"
  end if @food
end
</code></pre>

<p>  end
end</p>

<p>Animal.description</p>

<h1>We Can beathe Air</h1>

<h1>nil</h1>

<p>Animal.food_list</p>

<h1>nil</h1>

<p>Animal.food &lt;&lt; &ldquo;meat&rdquo;
Animal.food_list</p>

<h1>We like meat{% endcodeblock %}</h1>

<p>看來我們無法在<code>class &lt;&lt; self</code>的裡面直接定義<code>@</code>的類別實體變數，若非要在該區塊內設定<code>@</code>的類別實體變數，得借用類別方法來完成！</p>

<h3>參考</h3>

<p><a href="https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/45-more-classes/lessons/113-class-variables">Class Variables and Methods</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用pre-commit來修煉codestyle]]></title>
    <link href="http://noelsaga.herokuapp.com/blog/2015/07/22/shi-yong-pre-commitlai-xiu-lian-codestyle/"/>
    <updated>2015-07-22T01:35:26+08:00</updated>
    <id>http://noelsaga.herokuapp.com/blog/2015/07/22/shi-yong-pre-commitlai-xiu-lian-codestyle</id>
    <content type="html"><![CDATA[<p>想寫出有<strong>執行效率</strong>、又<strong>簡潔易讀</strong>、<del>又潮</del>的ruby codestyle嗎？</p>

<p>雖然不是人人都有大神幫忙做code review，但慶幸ruby有<code>rubocop</code>可以用，裡面可以偵測我們的code是否有符合ruby codestyle的最適規範，而且還可以搭配<code>pre-commit</code>，這個gem來幫我們做到每次提交commit前先掃描我們的code，看看是否有符合codestyle，沒有符合的話就不給commit，希望借此養成良好的codestyle！</p>

<!--more-->


<h3>1. 首先安裝gem</h3>

<p><code>
gem 'pre-commit', require: false
gem 'rubocop', require: false
</code></p>

<h3>2.新增檔案 rails_project/.robocup.yml</h3>

<p>這部份我都是手動新增的，裡面定義了一些基礎的客製化規範，照抄前輩挑選的，大家如果沒特定需求也可以照抄
{% codeblock lang:yml %}
AllCops:
  RunRailsCops: true
  Exclude:</p>

<pre><code>- db/schema.rb
</code></pre>

<p>Metrics/LineLength:
  Max: 120</p>

<p>Metrics/MethodLength:
  Max: 20</p>

<p>Metrics/ClassLength:
  Max: 250</p>

<p>Style/AsciiComments:
  Enabled: false</p>

<p>Style/ClassAndModuleChildren:
  EnforcedStyle: compact</p>

<p>Style/Documentation:
  Enabled: false</p>

<p>Style/IfUnlessModifier:
  Enabled: false
{% endcodeblock %}</p>

<h3>3.新增檔案 config/pre_commit.yml</h3>

<h2>{% codeblock lang:yml %}</h2>

<p>:checks_remove: []
:checks_add:
&ndash; :tabs
&ndash; :nb_space
&ndash; :whitespace
&ndash; :merge_conflict
&ndash; :debugger
&ndash; :pry
&ndash; :local
&ndash; :jshint
&ndash; :console_log
&ndash; :migration
&ndash; :rubocop
{% endcodeblock %}</p>

<h3>4. 執行<code>pre-commit install</code></h3>

<p>之後，每次開始提交commit就會在terminal下看到執行的結果了！然後就乖乖的養成良好的習慣慢慢改吧，雖然一開始會不習慣，但是之後會發現真的挺受用的！<br/>
如果有看不懂的提示也可以去Google找或是去<a href="https://github.com/bbatsov/ruby-style-guide#underscore-unused-vars">ruby-style-guide</a>翻閱看看，裡面都有解釋為何這樣設計或是範例。</p>

<h3>5.補充</h3>

<p>若想偷懶強制commit上去可以加上參數<code>-n</code></p>

<p><code>git commit -am 'some message' -n</code></p>

<h3>參考：<a href="https://github.com/jish/pre-commit">github: pre-commit</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Each_with_object vs Reduce]]></title>
    <link href="http://noelsaga.herokuapp.com/blog/2015/06/03/ruby-each-with-object-vs-reduce/"/>
    <updated>2015-06-03T23:37:29+08:00</updated>
    <id>http://noelsaga.herokuapp.com/blog/2015/06/03/ruby-each-with-object-vs-reduce</id>
    <content type="html"><![CDATA[<p>又發現一個好用的方法<code>each_with_object</code>，是屬於<em>Enumerable</em>的方法之一，最近看前輩的code才發現的，算是each家族中的一員，不得不說ruby內建的許多列舉方法實在是非常方便啊！它與前陣子介紹的<code>reduce</code>目的上有點類似，但似乎更為易懂，直接來看範例吧！</p>

<!--more-->


<p>{% codeblock lang:rb each_with_object 範例一 %}</p>

<pre><code>%w(red blue yello black).each_with_object({}) do |value, hash|
    hash.store(value, value.capitalize + '!')
end
# =&gt; {"red"=&gt;"Red!", "blue"=&gt;"Blue!", "yello"=&gt;"Yello!", "black"=&gt;"Black!"}
</code></pre>

<p>{% endcodeblock %}</p>

<h2>介紹</h2>

<p>範例一其實就只是把一個陣列迭代做些處理後存入hash裡，然後依序下去直到迭代完成，是不是很熟悉呢？沒錯，類似的功能<code>reduct/inject</code>也做得到，甚至你單用each也是可以，但是<code>each_with_object</code>更方便簡單，<strong>你必須先指定一個參數</strong>當做一個容器的初始值，此例就是hash，然後每次迭代之後他會自動記住容器的狀態，並自動代入下次迭代，這裡與<code>reduce</code>不太一樣，寫法上是更簡當方便，剛剛的範例如果用<code>reduce</code>寫的話則是：</p>

<p>{% codeblock lang:rb reduce 範例一 %}</p>

<pre><code>%w(red blue yello black).reduce({}) do |result, value|
    result.store(value, value.capitalize + '!')
    result
end
# =&gt; {"red"=&gt;"Red!", "blue"=&gt;"Blue!", "yello"=&gt;"Yello!", "black"=&gt;"Black!"}
</code></pre>

<p>{% endcodeblock %}</p>

<p>最後輸出是一樣的，但<code>reduce</code>我們必須自己把結果擺在最後一行(<del>return</del>)，<code>reduce</code>才會把它當作下次繼續迭代的<strong><em>結果值</em></strong>，這點對某些人可能比較不是那麼地直覺。</p>

<p>來看看另一個<code>each_with_object</code>的應用範例，讓我們來使用該函式做出類似select的效果</p>

<p>{% codeblock lang:rb each_with_object 範例二：模仿select %}</p>

<pre><code>(1..9).each_with_object([]) do |value, array|
    array &lt;&lt; value unless (value % 2 == 0)
 end      
# =&gt; [1, 3, 5, 7, 9]
</code></pre>

<p>{% endcodeblock %}</p>

<p>基本上你可以依需求或你傳入的參數類型來自由使用該方法進而達到任何可能的功能，而可傳入的參數可以是array、hash、甚至是openstruct，所以object或hashie當然應該也可以，有興趣的人可以自己玩玩看。</p>

<h2>與reduce差別</h2>

<p>雖然這個方法看似很潮、很精簡，但還是有些使用上的限制與和<code>reduce</code>的差別，像是:</p>

<ol>
<li>each_with_object必須傳入一個參數，reduce則不然</li>
<li>each_with_object接受的參數必須是容器型，不能是純值</li>
<li>each_with_object程式區塊的參數順序與reduce相反，each家族都是以個別值為第一個參數</li>
</ol>


<p>第一與第三點應該非常直覺好懂，第二點則需要說明一下，因為each_with_object可以自己記住迭代回傳結果，而該結果也必須在使用該方法時就給定，如果此時你給他的參數是純值像是int、str、boolean等型態的物件，則會因為屬於純值而無法改變或操縱物件本身，所以永遠都會回傳自己，如以下範例:</p>

<p>{% codeblock lang:rb each_with_object 範例三：參數給數字 %}</p>

<pre><code>(1..5).each_with_object(1) do |value, array|
    value * array
 end      
# =&gt; 1 而非 120
</code></pre>

<p>{% endcodeblock %}</p>

<p>以上就是該方法的介紹與分享，如果有問題或是發現小弟有哪邊有錯誤都請歡迎指教唷，感謝各位</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Methods Map Reduce]]></title>
    <link href="http://noelsaga.herokuapp.com/blog/2014/08/22/ruby-methods-map-reduce/"/>
    <updated>2014-08-22T00:36:38+08:00</updated>
    <id>http://noelsaga.herokuapp.com/blog/2014/08/22/ruby-methods-map-reduce</id>
    <content type="html"><![CDATA[<br>


<h2>關於迭代（iterator）</h2>

<br>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;簡單的說，迭代就是重複某一過程，若以coding來，迭代器可以幫助我們走訪array或hash的每一個元素並執行某些要求或命令，而ruby則是善用迭代來讓我們更少地直接使用傳統的迴圈功能，以讓程式可以更精簡、直覺。而ruby內建的迭代函式真的很多，也非常的好用，常見的如select, find ,find_all, reject&hellip;等可以幫我們快速迭代array或是hash甚至物件內的元素，以快速達到某些目的，例如我們想找到陣列中的偶數:</p>

<!-- more -->


<h3>ruby內建迭代函式寫法</h3>

<p>{% codeblock lang:ruby %}
[1,2,3,4,5,6,7,8,9].find_all do |n|
  n%2 == 0
end</p>

<h1>結果 [2,4,6,8]</h1>

<p>{% endcodeblock %}</p>

<h3>傳統迴圈寫法:</h3>

<p>{% codeblock lang:ruby %}
array = [1,2,3,4,5,6,7,8,9]
result = []
for n in array
  result &lt;&lt; n if n%2 == 0
end</p>

<h1>result: [2,4,6,8]</h1>

<p>result.clear # 洗白
i = 0
while(i&lt;array.length)
  result &lt;&lt; array[i] if array[i]%2 == 0
  i += 1
end</p>

<h1>result: [2,4,6,8]</h1>

<p>{% endcodeblock %}</p>

<br>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寫慣c、java或php的人可能較熟習傳統迴圈寫法，雖然可以達成功能，但既然ruby已經幫我們都包成好用的迭代函式，那我們何不好好善用呢？！當然熟悉傳統迴圈的寫法也是可以讓我們理解迭代函式背後的原理，但在使用上建議各位多多利用這些函式吧，在ruby中，我們將會習慣使用迭代函式而非迴圈。</p>

<p>   常使用的迭代函式像有select, find, find_all, each, each_with_index, collect, reject, delete_if, grep, any?, all?, sort, sort_by, map, reduce等逐繁不及備載，而許多迭代函式的功用也非常相似，所以如何使用且看使用者習慣或喜好。</p>

<hr />

<h2>Map函式</h2>

<br>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map函式與each最大的不同是他會回傳一個新的陣列，而陣列的結果則是根據我們在程式區塊(block)裡所定義的來對原陣列做修改，其實這用途非常常見，像是我們有16名學生的原始成績，想幫他們做開根號在除以10後得到的加權成績:</p>

<p>{% codeblock lang:ruby %}
scores = [68, 84, 92, 34, 79, 82, 80, 85, 80, 31, 25, 45, 46, 30, 42, 34]
new_scores = scores.map do |n|
  (Math.sqrt(n)*10).round(2)
end</p>

<h1>scores: [68, 84, 92, 34, 79, 82, 80, 85, 80, 31, 25, 45, 46, 30, 42, 34]</h1>

<h1>new_scores: [82.46, 91.65, 95.92, 58.31, 88.88, 90.55, 89.44, 92.2, 89.44, 55.68, 50.0, 67.08, 67.82, 54.77, 64.81, 58.31]</h1>

<p>array = [[1,2],[3,4],[5,6],[7,8]]
array.map do |n|
  n.lasy # 只要最後一個元素
end</p>

<h1>[2,4,6,8]</h1>

<p>t = Topic.scoped.map(&amp;:name)
t = Topic.scoped.pluck(:name)
{% endcodeblock %}</p>

<br>


<p>所以，如果我們希望能回傳迭代後的結果則使用map</p>

<hr />

<h2>Reduce函式</h2>

<br>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduce是比較抽象一點的迭代函式，但功能非常強大，它幫助我們逐一迭代元素外，還會保有一個結果變數可跟隨著迭代過程一起存活並最終回傳這個結果，而最後一行的值則是會迭代到下次做計算的初始值，所以最後一行切記不要使用puts或會回傳nil的函式，不然會哭哭唷！</p>

<br>


<p>{% codeblock lang:ruby %}
[1,2,3,4,5,6,7,8,9].reduce do |sum,value|
   sum += value
end</p>

<h1>45</h1>

<p>{% endcodeblock %}</p>

<br>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中在程式區塊內我們宣告的第一個變數sum即是那個所謂的結果變數，會一直跟隨迭代所存活並作為最後結果回傳，第二個變數value則是會跟隨陣列不斷迭代的個別值，然而我們也可以在一開始使用reduce時便賦予sum一個初始值；若我們沒有給初始值的話，sum則一開始會以陣列的第一個值，然後直接從第二的值開始做迭代。</p>

<br>


<p>{% codeblock lang:ruby %}
[1,2,3,4,5,6,7,8,9].reduce(50) do |sum,value|
   sum += value
 end
 # 95
{% endcodeblock %}</p>

<br> 


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到這邊可能會覺得很方便，但不以為然，若是不用reduce，我們過去的作法會是先在迭代範圍外先宣告一個變數，才能在範圍內使用此變數，而reduce則是把它包在一起使用。</p>

<br>


<p>{% codeblock lang:ruby %}
sum = 0
[1,2,3,4,5,6,7,8,9].each do |n|
  sum += n
end</p>

<h1>sum: 45</h1>

<h1>也可以這樣使用</h1>

<p>[1,2,3,4,5,6,7,8,9].reduce(:+)</p>

<h1>45</h1>

<p>[1,2,3,4,5,6,7,8,9].reduce(10,:+)</p>

<h1>55</h1>

<p>{% endcodeblock %}</p>

<h3>模仿select功能</h3>

<br>


<p>{% codeblock lang:ruby%}
[1,2,3,4,5,6,7,8,9].reduce([]) do |result, value|
  result &lt;&lt; value if value%2 == 0
  result  # 注意，這行如果不寫他會回傳nil，因為當1迭代進去時，不符合規則所以會回傳nil，這樣result下一次就會變成nil了而非[]
end</p>

<p>{% endcodeblock %}</p>

<h3>模仿map功能</h3>

<br>


<p>{% codeblock lang:ruby%}
[1,2,3,4,5,6,7,8,9].reduce() do |result, value|
  result &lt;&lt; Math.sqrt(value)/10
  result<br/>
end
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyWay: Net::HTTP篇]]></title>
    <link href="http://noelsaga.herokuapp.com/blog/2014/08/21/ruby-net-http/"/>
    <updated>2014-08-21T23:53:47+08:00</updated>
    <id>http://noelsaga.herokuapp.com/blog/2014/08/21/ruby-net-http</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>這算是比較抽象的一篇，目前我也不是很清楚他實際的作用與原理，但先記錄一下我所學到的部分與應用。</p>

<h2>get_response</h2>

<p> 有時候我們會需要在程式裡發出一個request，簡單的說就想像我們直接在瀏覽器裡輸入一串url，此時我們就可以利用Net::HTTP.get_response(<em>你要的uri</em>)，會回傳一個物件，而我們可以根據這個物件做我們想要的應用，看程式碼教學：</p>

<!-- more -->


<p>{% codeblock lang:rb 使用講解:Get %}</p>

<pre><code>require 'net/http'
#方法一
uri = URI.perse("example.com/bar/dosomething")  ＃先解析成uri物件比較方便
response = Net::HTTP.get_response(uri) # 回傳物件就是我們要的東西，我們可以利用他做很多事

#方法二
http = Net::HTTP.new(uri.host,uri.port)
response = http.request(Net::HTTP::Get.new(uri.request_uri))  #切記Get.new()的參數是request_uri不是uri

Net::HTTP.get_print(uri)   #印出response.body


response.code       # 回傳http狀態碼
response.body       # 回傳整個body內容，通常是編碼過不是人能看的東西
response.message    # 回傳HTTP狀態碼代表訊息 ex："Moved Permanently" 
response.uri        # 回傳呼叫它的uri物件

#uri物件也是個很方便的東西裡面常見的功能有

uri.request_uri     # 回傳你的request ex: /bar/dosomething
uri.host            # 回傳domain
uri.path            # 同request_uri
uri.scheme          # 回傳使用的傳輸協定
uri.query           # 回傳querysting
uri.port            # 回傳使用的port

#query_string處理
params = { :limit =&gt; 10, :page =&gt; 3 }
uri.query = URI.encode_www_form(params)
</code></pre>

<p>{% endcodeblock  %}
應用範例：預留一個版位顯示response.body的結果，利用Net::HTTP對某伺服器發送一個請求，並且把回傳的結果存入memcache以利用來顯示到預留的版位上。嗯嗯，聽起來有點像是ajax的概念，只是由伺服器端坐的而且他是同步的&hellip;</p>

<p>{% codeblock lang:rb 應用範例:Get %}</p>

<pre><code>response = Net::HTTP.get_response(URI.parse("http://foobar.header.com/api"))
if response.code.to_i == 200
  $memcached.set("header-html", response.body, 0)
end

某一處的VIEW顯現出來

&lt;%= raw $memcached.get("header-html").to_s.force_encode("utf8") %&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<hr />

<h2>post_form</h2>

<p>同理，有get方法就會有post方法，post方法一般用在傳送伺服器的的資料量大或是比較需要顧慮到安全時會用的！直接看教學範例：
{% codeblock lang:rb 使用範例:Post %}</p>

<pre><code>require "net/http"

uri = URI.parse("http://example.com/foo/search")

#方法一
response = Net::HTTP.post_form(uri, {"data" =&gt; "My data blah blah", "per_page" =&gt; "50"})

#方法二
http = Net::HTTP.new(uri.host, uri.port)
request = Net::HTTP::Post.new(uri.request_uri)
request.set_form_date({"data" =&gt; "My data blah blah", "per_page" =&gt; "50"})
response = http.request(request)
</code></pre>

<p>{% endcodeblock %}</p>

<h2>REST methods</h2>

<p>有寫過rails的人相信都對RESTful不陌生，所以直接看範例吧！
{% codeblock lang:rb 使用範例:REST %}</p>

<pre><code>require "net/http"

uri = URI.parse("http://api.noelsaga.net/")

http = Net::HTTP.new(uri.host, uri.port) #

#Get : 通常是讀取單一筆資料如show
response = http.request(Net::HTTP::Get.new("/post/1"))

#Post: 通常是用來建立資料
request = (Net::HTTP::Post.new("/post/1"))
request.set_form_date({:tilte =&gt; "Monday", :content =&gt; "I'm wanna go home..."})
response = http.request(request)

#Put : 通常是用來更新一筆資料
request = (Net::HTTP::Put.new("/post/1"))
request.set_form_date({:title =&gt; "Tuesday"})
response = http.request(request)

#Delete: 嗯嗯，字面意思很清楚了
request = (Net::HTTP::Delete.new("/post/1"))
response = http.request(request)
</code></pre>

<p>{% endcodeblock %}</p>

<h2>SSL/HTTPS request with PEM certificate</h2>

<p>如果是需要pem認證時，可以這麼做，此處直接使用Peter Cooper提供的範例</p>

<p>{% codeblock lang:rb 使用範例:PEM certificate %}</p>

<pre><code>require "net/https"
require "uri"

uri = URI.parse("https://secure.com/")
pem = File.read("/path/to/my.pem")
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true
http.cert = OpenSSL::X509::Certificate.new(pem)  # 根據pem檔案建立認證
http.key = OpenSSL::PKey::RSA.new(pem)            # 根據pem檔案建立認證
http.verify_mode = OpenSSL::SSL::VERIFY_PEER
request = Net::HTTP::Get.new(uri.request_uri)
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Post傳檔部分 （從缺中）</h2>

<p><a href="http://www.rubyinside.com/nethttp-cheat-sheet-2940.html">參考Peter Cooper文章</a></p>
]]></content>
  </entry>
  
</feed>
